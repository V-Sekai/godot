#!/usr/bin/env python
from misc.utility.scons_hints import *

Import("env")
Import("env_modules")

# Add include paths to global env so tests can access them
# Tests are compiled via tests/SCsub which uses env, not env_modules
# Note: LiteRT sources use #include "litert/c/..." so we need #thirdparty/litert (parent of litert/)
env.Prepend(CPPPATH=[
    "modules/litert",  # For module wrapper classes
    "#thirdparty/litert",  # For litert/c/ includes (allows litert/c/litert_common.h -> thirdparty/litert/litert/c/litert_common.h)
    "#thirdparty/flatbuffers/include",  # For flatbuffers headers (needed by tests)
    "#thirdparty/tensorflow-lite/tensorflow/lite",  # For tflite headers (needed by tests)
    "#thirdparty/tensorflow-lite/tensorflow",  # For tflite/schema includes
    "#thirdparty/litert/tflite",  # For tflite/converter/schema/mutable/ includes (needed by tests)
    "#thirdparty/litert/tflite/tensorflow/lite",  # Alternative path for tflite includes
])

env_litrt = env_modules.Clone()
# env_modules inherits from env, so it should have the paths above
# But ensure env_litrt also has them explicitly for thirdparty sources
# Note: LiteRT sources use #include "litert/c/..." so we need #thirdparty/litert (parent of litert/)
env_litrt.Prepend(CPPPATH=[
    "modules/litert",  # For module wrapper classes
    "#thirdparty/litert",  # For litert/c/ includes (allows litert/c/litert_common.h -> thirdparty/litert/litert/c/litert_common.h)
])

# Thirdparty source files - build litert static library

thirdparty_obj = []

thirdparty_dir = "#thirdparty/litert/litert/"

# C API sources
c_api_sources = [
    "c/litert_common.cc",
    "c/litert_compiled_model.cc",
    "c/litert_environment.cc",
    "c/litert_environment_options.cc",
    "c/litert_event.cc",
    "c/litert_layout.cc",
    "c/litert_metrics.cc",
    "c/litert_model.cc",
    "c/litert_op_options.cc",
    "c/litert_opaque_options.cc",
    "c/litert_options.cc",
    "c/litert_profiler.cc",
    "c/litert_rewriter.cc",
    "c/litert_tensor_buffer.cc",
    "c/litert_tensor_buffer_requirements.cc",
    "c/internal/litert_accelerator.cc",
    "c/internal/litert_accelerator_registration.cc",
    "c/internal/litert_delegate_wrapper.cc",
    "c/internal/litert_logging.cc",
    "c/internal/litert_tensor_buffer_registry.cc",
]

# Options sources
options_sources = [
    "c/options/litert_compiler_options.cc",
    "c/options/litert_cpu_options.cc",
    "c/options/litert_darwinn_runtime_options.cc",
    "c/options/litert_google_tensor_options.cc",
    "c/options/litert_gpu_options.cc",
    "c/options/litert_intel_openvino_options.cc",
    "c/options/litert_mediatek_options.cc",
    "c/options/litert_qualcomm_options.cc",
    "c/options/litert_runtime_options.cc",
    "c/options/litert_webnn_options.cc",
]

# Runtime sources
runtime_sources = [
    "runtime/accelerator_registry.cc",
    "runtime/accelerators/auto_registration.cc",
    "runtime/accelerators/dispatch/dispatch_accelerator.cc",
    # "runtime/accelerators/xnnpack/xnnpack_accelerator.cc",  # Disabled - XNNPACK not available
    "runtime/compiled_model.cc",
    "runtime/custom_buffer.cc",
    "runtime/custom_op_dispatcher.cc",
    "runtime/dispatch/dispatch_delegate.cc",
    "runtime/dispatch/dispatch_delegate_kernel.cc",
    "runtime/dispatch/dispatch_opaque_options.cc",
    "runtime/dispatch/litert_dispatch.cc",
    "runtime/event.cc",
    "runtime/external_litert_buffer_context.cc",
    "runtime/profiler.cc",
    "runtime/tensor_buffer.cc",
    "runtime/tensor_buffer_registry.cc",
    "runtime/tensor_buffer_requirements.cc",
    "runtime/tfl_utils.cc",
    "runtime/magic_number_utils.cc",
]

# Core sources
core_sources = [
    "core/build_stamp.cc",
    "core/buffer_error_reporter.cc",
    "core/error_reporter.cc",
    "core/dispatch_op_schema.cc",
    "core/environment.cc",
    "core/environment_options.cc",
    "core/filesystem.cc",
    "core/util/flatbuffer_tools.cc",
    "core/util/tensor_type_util.cc",
    "core/model/model.cc",
    "core/model/model_buffer.cc",
    "core/model/model_load.cc",
    # "core/model/model_serialize.cc",  # Requires tflite/schema/mutable/schema_generated.h which isn't available
    "core/model/flatbuffer_to_litert.cc",
    "core/model/litert_to_flatbuffer.cc",
    "core/model/graph_validation.cc",
    "core/cache/compilation_cache.cc",
]

# Platform-specific sources
if env["platform"] == "windows":
    core_sources.append("core/dynamic_loading_windows.cc")
else:
    core_sources.append("core/dynamic_loading.cc")

# Platform-specific GPU sources (enabled for GPU support)
# gpu_environment.cc is always needed for GPU support
runtime_sources.append("runtime/gpu_environment.cc")

# Metal support removed - WebGPU-only backend strategy

# CC API sources (C++ wrapper sources)
cc_sources = [
    "cc/litert_tensor_buffer_types.cc",
    "cc/internal/litert_tensor_buffer_utils.cc",
    "cc/litert_macros.cc",  # For ErrorStatusBuilder::LogMessage
    "cc/internal/litert_shared_library.cc",  # For SharedLibrary implementation
]

# Build ALL LiteRT source files (excluding vendors, tests, samples, tools, etc.)
litert_all_sources = [
    # ATS files may require vendor-specific code - exclude for now
    # "ats/ats.cc",
    # "ats/check_ats.cc",
    # "ats/configure.cc",
    "c/empty.cc",
    "c/internal/litert_accelerator.cc",
    "c/internal/litert_accelerator_registration.cc",
    "c/internal/litert_delegate_wrapper.cc",
    "c/internal/litert_external_litert_buffer_context.cc",
    "c/internal/litert_logging.cc",
    "c/internal/litert_tensor_buffer_registry.cc",
    "c/litert_common.cc",
    "c/litert_compiled_model.cc",
    "c/litert_environment.cc",
    "c/litert_environment_options.cc",
    "c/litert_event.cc",
    "c/litert_layout.cc",
    "c/litert_metrics.cc",
    "c/litert_model.cc",
    "c/litert_op_options.cc",
    "c/litert_opaque_options.cc",
    "c/litert_options.cc",
    "c/litert_profiler.cc",
    "c/litert_rewriter.cc",
    "c/litert_tensor_buffer.cc",
    "c/litert_tensor_buffer_requirements.cc",
    "c/options/litert_compiler_options.cc",
    "c/options/litert_cpu_options.cc",
    "c/options/litert_darwinn_runtime_options.cc",
    "c/options/litert_google_tensor_options.cc",
    "c/options/litert_gpu_options.cc",
    "c/options/litert_intel_openvino_options.cc",
    "c/options/litert_mediatek_options.cc",
    "c/options/litert_qualcomm_options.cc",
    "c/options/litert_runtime_options.cc",
    "c/options/litert_webnn_options.cc",
    "cc/internal/litert_compiled_model_next.cc",
    "cc/internal/litert_extended_model.cc",
    "cc/internal/litert_model_predicates.cc",
    "cc/internal/litert_op_options.cc",
    "cc/internal/litert_rewriter.cc",
    # "cc/internal/litert_rng.cc",  # Has template compilation error
    "cc/internal/litert_shared_library.cc",
    "cc/internal/litert_tensor_buffer_utils.cc",
    "cc/internal/test_shared_library.cc",
    "cc/litert_compiled_model.cc",
    "cc/litert_custom_op_kernel.cc",
    "cc/litert_macros.cc",
    "cc/litert_model.cc",
    "cc/litert_opaque_options.cc",
    "cc/litert_tensor_buffer.cc",
    "cc/litert_tensor_buffer_types.cc",
    "cc/options/compiler_options.cc",
    "cc/options/darwinn_options.cc",
    "cc/options/litert_cpu_options.cc",
    "cc/options/litert_google_tensor_options.cc",
    "cc/options/litert_gpu_options.cc",
    "cc/options/litert_intel_openvino_options.cc",
    "cc/options/litert_magic_number_options.cc",
    "cc/options/litert_mediatek_options.cc",
    "cc/options/litert_qualcomm_options.cc",
    "cc/options/litert_runtime_options.cc",
    "cc/options/litert_webnn_options.cc",
    "compiler/plugin/algo.cc",
    "compiler/plugin/compiler_plugin.cc",
    "core/buffer_error_reporter.cc",
    "core/build_stamp.cc",
    "core/cache/compilation_cache.cc",
    "core/dispatch_op_schema.cc",
    "core/dynamic_loading.cc",
    "core/dynamic_loading_windows.cc",
    "core/environment.cc",
    "core/environment_options.cc",
    "core/error_reporter.cc",
    "core/filesystem.cc",
    "core/model/flatbuffer_to_litert.cc",
    "core/model/graph_validation.cc",
    "core/model/litert_to_flatbuffer.cc",
    "core/model/model.cc",
    "core/model/model_buffer.cc",
    "core/model/model_file_test_util.cc",
    "core/model/model_load.cc",
    # "core/model/model_serialize.cc",  # Requires tflite/schema/mutable/schema_generated.h which isn't available
    "core/util/flatbuffer_tools.cc",
    "core/util/perfetto_profiling.cc",
    "core/util/tensor_type_util.cc",
    "runtime/accelerator_registry.cc",
    "runtime/accelerators/auto_registration.cc",
    "runtime/accelerators/dispatch/dispatch_accelerator.cc",
    "runtime/accelerators/xnnpack/xnnpack_accelerator.cc",
    "runtime/ahwb_buffer.cc",
    "runtime/compiled_model.cc",
    "runtime/custom_buffer.cc",
    "runtime/custom_op_dispatcher.cc",
    "runtime/dispatch/dispatch_delegate.cc",
    "runtime/dispatch/dispatch_delegate_kernel.cc",
    "runtime/dispatch/dispatch_opaque_options.cc",
    "runtime/dispatch/litert_dispatch.cc",
    "runtime/dispatch/litert_dispatch_dummy.cc",
    "runtime/dmabuf_buffer.cc",
    "runtime/event.cc",
    "runtime/external_litert_buffer_context.cc",
    "runtime/fastrpc_buffer.cc",
    "runtime/gl_buffer.cc",
    "runtime/gl_texture.cc",
    "runtime/gpu_environment.cc",
    "runtime/ion_buffer.cc",
    "runtime/magic_number_utils.cc",
    # "runtime/metal_info.cc",  # Requires Metal headers (macOS only)
    # "runtime/open_cl_memory.cc",  # Requires OpenCL headers (optional)
    # "runtime/open_cl_sync.cc",  # Requires OpenCL headers (optional)
    "runtime/profiler.cc",
    "runtime/tensor_buffer.cc",
    "runtime/tensor_buffer_registry.cc",
    "runtime/tensor_buffer_requirements.cc",
    "runtime/tfl_utils.cc",
]

# Filter platform-specific files
if env["platform"] != "windows":
    # Remove Windows-specific file if not on Windows
    if "core/dynamic_loading_windows.cc" in litert_all_sources:
        litert_all_sources.remove("core/dynamic_loading_windows.cc")
else:
    # Remove Unix-specific file if on Windows
    if "core/dynamic_loading.cc" in litert_all_sources:
        litert_all_sources.remove("core/dynamic_loading.cc")

litert_sources = [thirdparty_dir + file for file in litert_all_sources]

# Add include paths
# Note: "#thirdparty/litert" is already added above, so litert/c/ includes work
env_litrt.Prepend(
    CPPPATH=[
        "#thirdparty/litert/litert/build_common/generated",  # For build_config.h (actual location)
        "#thirdparty/litert/litert",  # Direct path for litert/build_common/build_config.h includes
        thirdparty_dir + "build_common/generated",  # For build_config.h (alternative path)
        thirdparty_dir + "c",
        thirdparty_dir + "c/internal",
        thirdparty_dir + "c/options",
        thirdparty_dir + "runtime",
        thirdparty_dir + "runtime/accelerators",
        thirdparty_dir + "runtime/accelerators/dispatch",
        thirdparty_dir + "runtime/accelerators/xnnpack",
        thirdparty_dir + "runtime/dispatch",
        thirdparty_dir + "core",
        thirdparty_dir + "core/model",
        thirdparty_dir + "core/cache",
        thirdparty_dir + "core/util",
        thirdparty_dir + "cc",
        thirdparty_dir + "cc/internal",
        "#thirdparty/litert/",
        # Dependency include paths
        "#thirdparty/abseil-cpp",  # For absl:: headers
        "#thirdparty/flatbuffers/include",  # For flatbuffers:: headers
        "#thirdparty/xnnpack/include",  # For xnnpack headers
        "#thirdparty/pthreadpool/include",  # For pthreadpool headers
        "#thirdparty/tensorflow-lite/tensorflow/lite",  # For tflite:: headers (from git subrepo)
        "#thirdparty/tensorflow-lite/tensorflow",  # For tflite/schema/ includes
        "#thirdparty/litert/tflite",  # LiteRT's bundled tflite (if still needed)
        "#thirdparty/litert/tflite/tensorflow/lite",  # For tflite/schema/mutable/ includes
    ]
)

# Add compile definitions
env_litrt.Append(
    CPPDEFINES=[
        "LITERT_COMPILE_LIBRARY",
        "LITERT_DISABLE_OPENCL_SUPPORT",  # Disable OpenCL support (not needed for basic functionality)
        "TFLITE_BUILD_WITHOUT_XNNPACK",  # Disable XNNPACK (we built TFLite without it)
    ]
)

# Platform-specific compile definitions
if env["platform"] == "windows":
    # Windows-specific: disable MMAP for TFLite
    env_litrt.Append(
        CPPDEFINES=[
            "TFLITE_DISABLE_MMAP",
        ]
    )
else:
    # Unix-like platforms: enable MMAP
    env_litrt.Append(
        CPPDEFINES=[
            "TFLITE_ENABLE_MMAP",
        ]
    )

# Create thirdparty environment with warnings disabled
# env_litrt already has the include paths from above, including "#thirdparty/litert"
# This allows litert/c/litert_common.h to resolve to thirdparty/litert/litert/c/litert_common.h
env_thirdparty = env_litrt.Clone()
env_thirdparty.disable_warnings()
# LiteRT requires C++20 for designated initializers
if env["platform"] == "windows":
    env_thirdparty.Append(CXXFLAGS=["/std:c++20"])
else:
    env_thirdparty.Append(CXXFLAGS=["-std=c++20"])

# Build thirdparty sources
env_thirdparty.add_source_files(thirdparty_obj, litert_sources)

# Godot source files (wrapper classes)

module_obj = []

env_litrt.add_source_files(module_obj, "*.cpp")
env.modules_sources += module_obj

# Needed to force rebuilding the module files when the thirdparty library is updated.
env.Depends(module_obj, thirdparty_obj)

# Test files (doctest)
# Note: Tests are compiled via tests/test_main.cpp which includes module test headers
# The test files need access to litert headers, so ensure env.modules_env includes our paths
if env["tests"]:
    env_litrt.Append(CPPDEFINES=["TESTS_ENABLED"])
    # Add test files to module_obj - they'll be included via test_main.cpp
    # The include paths are already set in env_litrt above
    if env["platform"] in ["windows", "macos", "linux", "linuxbsd", "android"]:
        env_litrt.Append(CPPDEFINES=["DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS"])

# Build dependency libraries
# Note: These are complex libraries. For now, we include their source files.
# A full production build may require building these as separate static libraries.

# pthreadpool (simple - only 8 source files)
if True:  # Always build pthreadpool
    pthreadpool_dir = "#thirdparty/pthreadpool/"
    pthreadpool_sources = [
        "src/legacy-api.c",
        "src/memory.c",
        "src/shim.c",
        "src/portable-api.c",
    ]

    # Platform-specific sources
    if env["platform"] == "windows":
        pthreadpool_sources.append("src/windows.c")
    else:
        # Add GCD for macOS/iOS (pthreads.c is not used when GCD is enabled)
        if env["platform"] in ["macos", "ios"]:
            pthreadpool_sources.append("src/gcd.c")
        else:
            # Use pthreads.c for other Unix-like platforms (Linux, etc.)
            pthreadpool_sources.append("src/pthreads.c")
        # Add fastpath for x86/x86_64
        # Note: This would need platform detection, for now include it
        if env["platform"] not in ["windows"]:
            pthreadpool_sources.append("src/fastpath.c")

    pthreadpool_sources = [pthreadpool_dir + file for file in pthreadpool_sources]

    env_pthreadpool = env_thirdparty.Clone()
    env_pthreadpool.Prepend(CPPPATH=[
        pthreadpool_dir + "include",
        pthreadpool_dir + "src",  # For fxdiv.h if it's in deps/fxdiv/include
        "#thirdparty/fxdiv/include",  # FXdiv header-only library
    ])
    # C files are automatically compiled with CC compiler
    env_pthreadpool.add_source_files(thirdparty_obj, pthreadpool_sources)

# FlatBuffers library (only 4 source files needed - most is header-only)
if True:  # Always build flatbuffers
    flatbuffers_dir = "#thirdparty/flatbuffers/"
    flatbuffers_sources = [
        "src/idl_parser.cpp",
        "src/idl_gen_text.cpp",
        "src/reflection.cpp",
        "src/util.cpp",
    ]
    flatbuffers_sources = [flatbuffers_dir + file for file in flatbuffers_sources]

    env_flatbuffers = env_thirdparty.Clone()
    env_flatbuffers.Prepend(CPPPATH=[flatbuffers_dir + "include"])
    env_flatbuffers.add_source_files(thirdparty_obj, flatbuffers_sources)

# Abseil - Build ALL source files (no whack-a-mole approach)
if True:  # Build Abseil (all components)
    abseil_dir = "#thirdparty/abseil-cpp/"
    
    # Build ALL Abseil source files (excluding tests and benchmarks)
    abseil_all_sources = [
        "absl/base/internal/atomic_hook_test_helper.cc",
        "absl/base/internal/cycleclock.cc",
        "absl/base/internal/exception_safety_testing.cc",
        "absl/base/internal/low_level_alloc.cc",
        "absl/base/internal/poison.cc",
        "absl/base/internal/raw_logging.cc",
        "absl/base/internal/scoped_set_env.cc",
        "absl/base/internal/spinlock.cc",
        "absl/base/internal/spinlock_wait.cc",
        "absl/base/internal/strerror.cc",
        "absl/base/internal/sysinfo.cc",
        "absl/base/internal/thread_identity.cc",
        "absl/base/internal/throw_delegate.cc",
        "absl/base/internal/tracing.cc",
        "absl/base/internal/unscaledcycleclock.cc",
        "absl/base/log_severity.cc",
        # "absl/base/spinlock_test_common.cc",  # Test helper
        # "absl/container/internal/hash_generator_testing.cc",  # Test helper
        "absl/container/internal/hashtablez_sampler.cc",
        "absl/container/internal/hashtablez_sampler_force_weak_definition.cc",
        "absl/container/internal/raw_hash_set.cc",
        # "absl/container/internal/test_instance_tracker.cc",  # Test helper
        "absl/crc/crc32c.cc",
        "absl/crc/internal/cpu_detect.cc",
        "absl/crc/internal/crc.cc",
        "absl/crc/internal/crc_cord_state.cc",
        "absl/crc/internal/crc_memcpy_fallback.cc",
        "absl/crc/internal/crc_memcpy_x86_arm_combined.cc",
        "absl/crc/internal/crc_non_temporal_memcpy.cc",
        "absl/crc/internal/crc_x86_arm_combined.cc",
        "absl/debugging/failure_signal_handler.cc",
        "absl/debugging/internal/address_is_readable.cc",
        "absl/debugging/internal/decode_rust_punycode.cc",
        "absl/debugging/internal/demangle.cc",
        "absl/debugging/internal/demangle_rust.cc",
        "absl/debugging/internal/elf_mem_image.cc",
        "absl/debugging/internal/examine_stack.cc",
        "absl/debugging/internal/stack_consumption.cc",
        "absl/debugging/internal/utf8_for_code_point.cc",
        "absl/debugging/internal/vdso_support.cc",
        "absl/debugging/leak_check.cc",
        "absl/debugging/stacktrace.cc",
        "absl/debugging/symbolize.cc",
        "absl/flags/commandlineflag.cc",
        # "absl/flags/flag_test_defs.cc",  # Test helper
        "absl/flags/internal/commandlineflag.cc",
        "absl/flags/internal/flag.cc",
        "absl/flags/internal/private_handle_accessor.cc",
        "absl/flags/internal/program_name.cc",
        "absl/flags/internal/usage.cc",
        "absl/flags/marshalling.cc",
        "absl/flags/parse.cc",
        "absl/flags/reflection.cc",
        "absl/flags/usage.cc",
        "absl/flags/usage_config.cc",
        "absl/hash/internal/city.cc",
        "absl/hash/internal/hash.cc",
        "absl/hash/internal/print_hash_of.cc",
        "absl/log/die_if_null.cc",
        "absl/log/flags.cc",
        "absl/log/globals.cc",
        "absl/log/initialize.cc",
        "absl/log/internal/check_op.cc",
        "absl/log/internal/conditions.cc",
        "absl/log/internal/fnmatch.cc",
        "absl/log/internal/globals.cc",
        "absl/log/internal/log_format.cc",
        "absl/log/internal/log_message.cc",
        "absl/log/internal/log_sink_set.cc",
        "absl/log/internal/nullguard.cc",
        "absl/log/internal/proto.cc",
        "absl/log/internal/structured_proto.cc",
        # "absl/log/internal/test_actions.cc",  # Test helper
        # "absl/log/internal/test_helpers.cc",  # Test helper
        # "absl/log/internal/test_matchers.cc",  # Test helper
        "absl/log/internal/vlog_config.cc",
        "absl/log/log_entry.cc",
        "absl/log/log_sink.cc",
        # "absl/log/scoped_mock_log.cc",  # Test helper
        "absl/numeric/int128.cc",
        "absl/profiling/hashtable.cc",
        "absl/profiling/internal/exponential_biased.cc",
        "absl/profiling/internal/periodic_sampler.cc",
        "absl/profiling/internal/profile_builder.cc",
        # "absl/random/benchmarks.cc",  # Benchmark
        "absl/random/discrete_distribution.cc",
        "absl/random/gaussian_distribution.cc",
        "absl/random/internal/chi_square.cc",
        "absl/random/internal/distribution_test_util.cc",
        "absl/random/internal/entropy_pool.cc",
        "absl/random/internal/gaussian_distribution_gentables.cc",
        "absl/random/internal/nanobenchmark.cc",
        "absl/random/internal/randen.cc",
        # "absl/random/internal/randen_benchmarks.cc",  # Benchmark
        "absl/random/internal/randen_detect.cc",
        "absl/random/internal/randen_hwaes.cc",
        "absl/random/internal/randen_round_keys.cc",
        "absl/random/internal/randen_slow.cc",
        "absl/random/internal/seed_material.cc",
        "absl/random/seed_gen_exception.cc",
        "absl/random/seed_sequences.cc",
        "absl/status/internal/status_internal.cc",
        # "absl/status/internal/status_matchers.cc",  # Test helper
        "absl/status/status.cc",
        "absl/status/status_payload_printer.cc",
        "absl/status/statusor.cc",
        "absl/strings/ascii.cc",
        "absl/strings/charconv.cc",
        "absl/strings/cord.cc",
        "absl/strings/cord_analysis.cc",
        "absl/strings/escaping.cc",
        "absl/strings/internal/charconv_bigint.cc",
        "absl/strings/internal/charconv_parse.cc",
        "absl/strings/internal/cord_internal.cc",
        "absl/strings/internal/cord_rep_btree.cc",
        "absl/strings/internal/cord_rep_btree_navigator.cc",
        "absl/strings/internal/cord_rep_btree_reader.cc",
        "absl/strings/internal/cord_rep_consume.cc",
        "absl/strings/internal/cord_rep_crc.cc",
        "absl/strings/internal/cordz_functions.cc",
        "absl/strings/internal/cordz_handle.cc",
        "absl/strings/internal/cordz_info.cc",
        "absl/strings/internal/cordz_sample_token.cc",
        "absl/strings/internal/damerau_levenshtein_distance.cc",
        "absl/strings/internal/escaping.cc",
        "absl/strings/internal/memutil.cc",
        "absl/strings/internal/ostringstream.cc",
        "absl/strings/internal/pow10_helper.cc",
        "absl/strings/internal/str_format/arg.cc",
        "absl/strings/internal/str_format/bind.cc",
        "absl/strings/internal/str_format/extension.cc",
        "absl/strings/internal/str_format/float_conversion.cc",
        "absl/strings/internal/str_format/output.cc",
        "absl/strings/internal/str_format/parser.cc",
        "absl/strings/internal/stringify_sink.cc",
        "absl/strings/internal/utf8.cc",
        "absl/strings/match.cc",
        "absl/strings/numbers.cc",
        "absl/strings/str_cat.cc",
        "absl/strings/str_replace.cc",
        "absl/strings/str_split.cc",
        "absl/strings/string_view.cc",
        "absl/strings/substitute.cc",
        "absl/synchronization/barrier.cc",
        "absl/synchronization/blocking_counter.cc",
        "absl/synchronization/internal/create_thread_identity.cc",
        "absl/synchronization/internal/futex_waiter.cc",
        "absl/synchronization/internal/graphcycles.cc",
        "absl/synchronization/internal/kernel_timeout.cc",
        "absl/synchronization/internal/per_thread_sem.cc",
        "absl/synchronization/internal/pthread_waiter.cc",
        "absl/synchronization/internal/sem_waiter.cc",
        "absl/synchronization/internal/stdcpp_waiter.cc",
        "absl/synchronization/internal/waiter_base.cc",
        "absl/synchronization/internal/win32_waiter.cc",
        "absl/synchronization/mutex.cc",
        "absl/synchronization/notification.cc",
        "absl/time/civil_time.cc",
        "absl/time/clock.cc",
        "absl/time/duration.cc",
        "absl/time/format.cc",
        "absl/time/internal/cctz/src/civil_time_detail.cc",
        # "absl/time/internal/cctz/src/test_time_zone_names.cc",  # Test helper
        "absl/time/internal/cctz/src/time_zone_fixed.cc",
        "absl/time/internal/cctz/src/time_zone_format.cc",
        "absl/time/internal/cctz/src/time_zone_if.cc",
        "absl/time/internal/cctz/src/time_zone_impl.cc",
        "absl/time/internal/cctz/src/time_zone_info.cc",
        "absl/time/internal/cctz/src/time_zone_libc.cc",
        "absl/time/internal/cctz/src/time_zone_lookup.cc",
        "absl/time/internal/cctz/src/time_zone_posix.cc",
        "absl/time/internal/cctz/src/zone_info_source.cc",
        # "absl/time/internal/test_util.cc",  # Test helper
        "absl/time/time.cc",
    ]
    
    abseil_sources = [abseil_dir + file for file in abseil_all_sources]
    env_abseil = env_thirdparty.Clone()
    env_abseil.Prepend(CPPPATH=[abseil_dir])
    env_abseil.add_source_files(thirdparty_obj, abseil_sources)

# XNNPACK (extremely large - 8249 .c files) - OPTIONAL/SKIPPED
# NOTE: XNNPACK is only for CPU acceleration, not required for basic functionality
# TFLite can run without XNNPACK (slower but functional)
# For scrappiest approach: Skip XNNPACK entirely
# XNNPACK include paths are already added above for headers (won't break if unused)
# If XNNPACK is needed later, can be added as pre-built library or selective build

# TensorFlow Lite - Automatically build with CMake if not found
if True:  # Link TFLite library (auto-build if needed)
    import os
    import multiprocessing

    # Check multiple possible locations for the library
    tflite_build_dir = "#thirdparty/tensorflow-lite/build/"
    tflite_source_dir = "#thirdparty/tensorflow-lite/tensorflow/lite/"
    
    # Determine library extension based on platform
    if env["platform"] == "windows":
        lib_ext = ".lib"
        lib_name = "tensorflow-lite"
    else:
        lib_ext = ".a"
        lib_name = "libtensorflow-lite"
    
    tflite_lib_paths = [
        tflite_build_dir + lib_name + lib_ext,
        tflite_build_dir + "tensorflow/lite/" + lib_name + lib_ext,
        # Windows-specific paths
        tflite_build_dir + "Release/" + lib_name + lib_ext,
        tflite_build_dir + "tensorflow/lite/Release/" + lib_name + lib_ext,
        # Also check Unix-style .a for cross-platform builds
        tflite_build_dir + "libtensorflow-lite.a",
        tflite_build_dir + "tensorflow/lite/libtensorflow-lite.a",
    ]

    # Find the library
    tflite_lib_found = None
    # Get project root (SCons # prefix)
    project_root = env.Dir("#").abspath
    for lib_path in tflite_lib_paths:
        # SCons resolves # to project root, but os.path.exists doesn't
        actual_path = lib_path.replace("#", project_root + "/")
        if os.path.exists(actual_path):
            tflite_lib_found = lib_path
            break

    # If library not found, automatically build it with CMake
    if not tflite_lib_found:
        print("TensorFlow Lite library not found. Building with CMake...")
        
        # Get build directory path for os.makedirs
        tflite_build_path = os.path.join(project_root, "thirdparty", "tensorflow-lite", "build")
        
        # Create build directory if it doesn't exist
        # Check if it exists and is a directory first
        if os.path.exists(tflite_build_path):
            if not os.path.isdir(tflite_build_path):
                # If it's a file, remove it and create directory
                os.remove(tflite_build_path)
                os.makedirs(tflite_build_path, exist_ok=True)
        else:
            os.makedirs(tflite_build_path, exist_ok=True)
        
        # Determine number of parallel jobs
        try:
            num_jobs = multiprocessing.cpu_count()
        except:
            num_jobs = 4
        
        # Create SCons Command to run CMake configure and build
        # Use a sentinel file to track if build is needed
        cmake_sentinel = env.File(tflite_build_dir + ".cmake_configured")
        build_sentinel = env.File(tflite_build_dir + ".tflite_built")
        cmake_lists = env.File(tflite_source_dir + "CMakeLists.txt")
        
        # Get absolute paths for CMake commands
        build_dir_abs = env.Dir(tflite_build_dir).abspath
        source_dir_abs = env.Dir(tflite_source_dir).abspath
        cmake_sentinel_abs = env.File(cmake_sentinel).abspath
        build_sentinel_abs = env.File(build_sentinel).abspath
        
        # Configure CMake (run once)
        # Use Action to properly handle the command
        from SCons.Action import Action
        # Configure CMake with options to fix compatibility issues
        # Use the existing TensorFlow source directory to avoid downloading and version conflicts
        tensorflow_source_abs = os.path.join(project_root, "thirdparty", "tensorflow-lite")
        cmake_configure_cmd = (
            "cd " + build_dir_abs + " && " +
            "cmake " + source_dir_abs + " " +
            "-DCMAKE_BUILD_TYPE=Release " +
            "-DBUILD_SHARED_LIBS=OFF " +
            "-DTFLITE_ENABLE_GPU=OFF " +
            "-DTFLITE_ENABLE_XNNPACK=OFF " +
            "-DTFLITE_ENABLE_RESOURCE=OFF " +
            "-DTFLITE_ENABLE_SIGNATURE=ON " +
            "-DTENSORFLOW_SOURCE_DIR=" + tensorflow_source_abs + " " +
            "&& touch " + cmake_sentinel_abs
        )
        cmake_configure_action = Action(
            cmake_configure_cmd,
            cmdstr="Configuring TensorFlow Lite with CMake..."
        )
        env.Command(
            cmake_sentinel,
            cmake_lists,
            cmake_configure_action
        )
        
        # Build TFLite library (depends on configure)
        cmake_build_action = Action(
            "cd " + build_dir_abs + " && cmake --build . -j" + str(num_jobs) + " --target tensorflow-lite && touch " + build_sentinel_abs,
            cmdstr="Building TensorFlow Lite library..."
        )
        env.Command(
            build_sentinel,
            cmake_sentinel,
            cmake_build_action
        )
        
        # Re-check for library after build
        # Note: This will be evaluated at build time, so we need to make the library
        # a dependency of the build
        expected_lib_path = tflite_build_dir + lib_name + lib_ext
        expected_lib_file = env.File(expected_lib_path)
        tflite_lib_found = expected_lib_path
        
        # Make the library depend on the build - this ensures it's built before linking
        env.Depends(expected_lib_file, build_sentinel)
        
        # Make the module sources depend on the build sentinel so linking waits
        # This ensures CMake build completes before we try to link
        env.Depends(thirdparty_obj, build_sentinel)
        env.Depends(module_obj, build_sentinel)
    
    if tflite_lib_found:
        # Add the directory containing the library to LIBPATH
        # Use SCons Dir to properly resolve the path
        tflite_lib_file_path = env.File(tflite_lib_found)
        tflite_lib_dir = str(tflite_lib_file_path.dir)
        env_litrt.Append(LIBPATH=[tflite_lib_dir])
        
        # Link TensorFlow Lite's CMake-built dependencies
        # These are required because libtensorflow-lite.a was built with CMake
        # and expects these dependencies to be available at link time
        tflite_deps_dir = tflite_build_dir + "_deps"
        tflite_deps_abs = os.path.join(project_root, "thirdparty", "tensorflow-lite", "build", "_deps")
        
        # Add all dependency build directories to LIBPATH
        # This allows the linker to find all the dependency libraries
        if os.path.exists(tflite_deps_abs):
            # Add base directories for each dependency
            deps_build_dirs = [
                tflite_build_dir + "_deps/abseil-cpp-build",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/base",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/strings",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/flags",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/hash",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/status",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/synchronization",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/container",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/time",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/debugging",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/crc",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/numeric",
                tflite_build_dir + "_deps/abseil-cpp-build/absl/profiling",
                tflite_build_dir + "_deps/farmhash-build",
                tflite_build_dir + "_deps/fft2d-build",
                tflite_build_dir + "_deps/flatbuffers-build",
                tflite_build_dir + "_deps/gemmlowp-build",
                tflite_build_dir + "_deps/ruy-build/ruy",
                tflite_build_dir + "_deps/ruy-build/ruy/profiler",
                tflite_build_dir + "_deps/cpuinfo-build",
            ]
            
            # Add each directory to LIBPATH if it exists
            for dep_dir in deps_build_dirs:
                dep_abs = dep_dir.replace("#", project_root + "/")
                if os.path.exists(dep_abs):
                    env_litrt.Append(LIBPATH=[dep_dir])
            
            # Link TensorFlow Lite dependencies in the correct order
            # Order matters: dependencies must come after the libraries that depend on them
            # Based on tensorflow/lite/CMakeLists.txt target_link_libraries
            tflite_deps_libs = [
                # Ruy (matrix multiplication library)
                "ruy_frontend",
                "ruy_trmul",
                "ruy_prepare_packed_matrices",
                "ruy_prepacked_cache",
                "ruy_context",
                "ruy_context_get_ctx",
                "ruy_ctx",
                "ruy_thread_pool",
                "ruy_blocking_counter",
                "ruy_wait",
                "ruy_allocator",
                "ruy_system_aligned_alloc",
                "ruy_apply_multiplier",
                "ruy_tune",
                "ruy_denormal",
                "ruy_block_map",
                "ruy_cpuinfo",
                # Ruy platform-specific kernels (link all, linker will pick what's needed)
                "ruy_kernel_arm",
                "ruy_kernel_avx",
                "ruy_kernel_avx2_fma",
                "ruy_kernel_avx512",
                "ruy_pack_arm",
                "ruy_pack_avx",
                "ruy_pack_avx2_fma",
                "ruy_pack_avx512",
                "ruy_have_built_path_for_avx",
                "ruy_have_built_path_for_avx2_fma",
                "ruy_have_built_path_for_avx512",
                "ruy_profiler_instrumentation",
                # Gemmlowp (8-bit GEMM)
                "eight_bit_int_gemm",
                # FlatBuffers
                "flatbuffers",
                # FFT2D
                "fft2d_fftsg2d",
                "fft2d_fftsg",
                # Farmhash
                "farmhash",
                # CPU info
                "cpuinfo",
                # Abseil libraries (in dependency order)
                # Base libraries first
                "absl_base",
                "absl_spinlock_wait",
                "absl_raw_logging_internal",
                "absl_log_severity",
                "absl_malloc_internal",
                "absl_throw_delegate",
                "absl_strerror",
                "absl_tracing_internal",
                # Numeric
                "absl_int128",
                # Container
                "absl_raw_hash_set",
                "absl_hashtablez_sampler",
                # Strings (depends on base)
                "absl_strings",
                "absl_strings_internal",
                "absl_str_format_internal",
                "absl_cord",
                "absl_cord_internal",
                "absl_cordz_info",
                "absl_cordz_handle",
                "absl_cordz_functions",
                "absl_string_view",
                # Hash (depends on strings)
                "absl_hash",
                "absl_city",
                # Status (depends on base, strings)
                "absl_status",
                # Synchronization (depends on base, time)
                "absl_synchronization",
                "absl_graphcycles_internal",
                "absl_kernel_timeout_internal",
                # Flags (depends on strings, status)
                # Note: absl_flags is a CMake target, not a library - link individual components
                "absl_flags_internal",
                "absl_flags_commandlineflag",
                "absl_flags_commandlineflag_internal",
                "absl_flags_private_handle_accessor",
                "absl_flags_program_name",
                "absl_flags_config",
                "absl_flags_marshalling",
                "absl_flags_reflection",
                # Time (depends on base)
                "absl_time",
                "absl_time_zone",
                "absl_civil_time",
                # Debugging
                "absl_debugging_internal",
                "absl_symbolize",
                "absl_stacktrace",
                "absl_demangle_internal",
                "absl_demangle_rust",
                "absl_leak_check",
                "absl_utf8_for_code_point",
                "absl_decode_rust_punycode",
                # CRC
                "absl_crc32c",
                "absl_crc_internal",
                "absl_crc_cord_state",
                "absl_crc_cpu_detect",
                # Profiling
                "absl_exponential_biased",
            ]
            
            # Add all dependency libraries FIRST
            # These must be linked to satisfy TensorFlow Lite's dependencies
            env_litrt.Append(LIBS=tflite_deps_libs)
            
            # Link TensorFlow Lite library AFTER dependencies
            # On macOS, use -force_load to ensure all symbols are loaded from the static library
            # Static libraries only export symbols that are referenced, so we need -force_load
            if env["platform"] == "macos":
                tflite_lib_abs = os.path.join(project_root, "thirdparty", "tensorflow-lite", "build", "libtensorflow-lite.a")
                if not os.path.exists(tflite_lib_abs):
                    # Fallback: try to find the library
                    expected_lib_path = tflite_build_dir + "libtensorflow-lite.a"
                    tflite_lib_abs = expected_lib_path.replace("#", project_root + "/")
                
                if os.path.exists(tflite_lib_abs):
                    # Use -force_load with the absolute library path
                    # Format: -Wl,-force_load,<path> (single argument, comma-separated)
                    # This forces the linker to load ALL symbols from this specific library
                    # Create a File object for the library to ensure SCons tracks it properly
                    tflite_lib_file = env.File(tflite_lib_abs)
                    # Use the File object's absolute path in the -force_load flag
                    env_litrt.Append(LINKFLAGS=["-Wl,-force_load," + tflite_lib_file.abspath])
                    # Also add the File object to LIBS so SCons tracks it as a dependency
                    # The -force_load flag will ensure all symbols are loaded
                    env_litrt.Append(LIBS=[tflite_lib_file])
                else:
                    # Last resort: regular linking
                    env_litrt.Append(LIBS=["tensorflow-lite"])
            else:
                # For other platforms, link normally
                env_litrt.Append(LIBS=["tensorflow-lite"])
            
            # Add system libraries (dl on Unix, needed by TensorFlow Lite)
            if env["platform"] != "windows":
                env_litrt.Append(LIBS=["dl"])
        
        # Add TFLite minimal logging sources (not included in pre-built library)
        # Need both files: minimal_logging.cc provides Log(), GetSeverityName(), etc.
        # and minimal_logging_default.cc provides LogFormatted() and the static member
        tflite_logging_sources = [
            "#thirdparty/tensorflow-lite/tensorflow/lite/minimal_logging.cc",
            "#thirdparty/tensorflow-lite/tensorflow/lite/minimal_logging_default.cc",
        ]
        env_tflite_logging = env_thirdparty.Clone()
        env_tflite_logging.Prepend(CPPPATH=["#thirdparty/tensorflow-lite"])
        env_tflite_logging.add_source_files(thirdparty_obj, tflite_logging_sources)
        
        # Add TFLite error reporter source (needed for DefaultErrorReporter and ErrorReporter::Report)
        tflite_error_reporter_sources = [
            "#thirdparty/tensorflow-lite/tensorflow/compiler/mlir/lite/core/api/error_reporter.cc",  # For ErrorReporter::Report
            "#thirdparty/tensorflow-lite/tensorflow/lite/stderr_reporter.cc",  # For DefaultErrorReporter
        ]
        env_tflite_error_reporter = env_thirdparty.Clone()
        env_tflite_error_reporter.Prepend(CPPPATH=["#thirdparty/tensorflow-lite"])
        env_tflite_error_reporter.add_source_files(thirdparty_obj, tflite_error_reporter_sources)
        
        # Add TFLite allocation sources (needed for MemoryAllocation, MMAPAllocation, and GetAllocationFromFile)
        tflite_allocation_sources = [
            "#thirdparty/tensorflow-lite/tensorflow/compiler/mlir/lite/allocation.cc",
            "#thirdparty/tensorflow-lite/tensorflow/compiler/mlir/lite/mmap_allocation.cc",
            "#thirdparty/tensorflow-lite/tensorflow/compiler/mlir/lite/core/model_builder_base.cc",
        ]
        env_tflite_allocation = env_thirdparty.Clone()
        env_tflite_allocation.Prepend(CPPPATH=["#thirdparty/tensorflow-lite"])
        env_tflite_allocation.add_source_files(thirdparty_obj, tflite_allocation_sources)

# Add all thirdparty objects to modules_sources after all sources have been added
env.modules_sources += thirdparty_obj

# Metal framework linking removed - WebGPU-only backend strategy

# NOTE: Dependency linking requirements
# LiteRT requires the following dependencies to be built and linked:
#
# Status (Scrappiest Approach):
# - ✅ pthreadpool: Built from source (8 files, simple)
# - ✅ FlatBuffers: Built from source (4 library files - most is header-only)
# - ✅ Abseil: Minimal build complete (~25 source files) - includes base, status, strings, container components
# - ⏭️ XNNPACK: SKIPPED (optional acceleration - TFLite works without it)
# - ⚠️ TensorFlow Lite: Pre-built library approach - build separately with CMake, link libtensorflow-lite.a
#
# These dependencies are currently included as git subrepos in thirdparty/:
# - thirdparty/abseil-cpp (git subrepo)
# - thirdparty/flatbuffers (git subrepo)
# - thirdparty/xnnpack (git subrepo)
# - thirdparty/pthreadpool (git subrepo) ✅ Building from source
# - thirdparty/tensorflow-lite (git subrepo - full TensorFlow repo)
# - thirdparty/litert/tflite (LiteRT's bundled TensorFlow Lite sources, if used)
#
# Next steps for scrappiest integration (to get matmul working):
# 1. ✅ Build FlatBuffers library - DONE (4 source files)
# 2. ✅ Build pthreadpool - DONE (8 source files)
# 3. ✅ Complete Abseil minimal build - DONE (~25 source files)
#    - Includes: base (low_level_alloc, spinlock, sysinfo, etc.), status, strings, container
# 4. ⏭️ XNNPACK - SKIPPED (optional, not needed for basic functionality)
# 5. ⚠️ Build TensorFlow Lite separately - TODO
#    - Steps: cd thirdparty/tensorflow-lite && mkdir build && cd build
#    - Run: cmake ../tensorflow/lite -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DTFLITE_ENABLE_XNNPACK=OFF
#    - Build: cmake --build . -j$(nproc) --target tensorflow-lite
# 6. ✅ Link pre-built TFLite library - SETUP DONE (SCsub will find library in build directory)
#
# Current state: pthreadpool, flatbuffers, and Abseil are fully built from source.
# XNNPACK is skipped (optional). TFLite linking is set up - SCons will find libtensorflow-lite.a
# in thirdparty/tensorflow-lite/build/ automatically when it exists.
